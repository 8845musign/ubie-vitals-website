---
import type { Prop } from '../../types';
import { valueKeywordMap } from '../../utils/server/props/valueKeywordMap';
import { convertKeyOrValue } from '../../utils/server/props/convertKeyOrValue';

interface Props {
  propsArray: Prop[];
}

const { propsArray } = Astro.props;

const normalizedProps = propsArray.map((prop) => {
  return Object.assign({}, prop, {
    type: [
      [prop.type].flat(Infinity).map((t) => {
        return convertKeyOrValue(t as string);
      }),
    ].flat(Infinity),
  });
});
---

{
  propsArray.length === 0 ? (
    <p>Propsの説明がありません</p>
  ) : (
    <div class="tableWrapper">
      <table class="table">
        <thead>
          <tr>
            <th>Name</th>
            <th class="type">Type</th>
            <th>Default</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          {normalizedProps.map((prop) => (
            <tr>
              <th scope="row" class="nowrap">
                {prop.name}
                {prop.required && <div class="required">required</div>}
                {!prop.required && !prop.defaultValue && <div class="optional">optional</div>}
              </th>
              <td class="type">
                {Array.isArray(prop.type) ? (
                  prop.type.map((type, i) => {
                    return (
                      <div class="typeItem">
                        <code>{type}</code>
                      </div>
                    );
                  })
                ) : (
                  <code>{convertKeyOrValue(prop.type)}</code>
                )}
              </td>
              <td>
                <code>{prop.defaultValue || '-'}</code>
              </td>
              <td>{prop.description || '-'}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  )
}

<style>
  .tableWrapper {
    border: 1px solid var(--color-border);
    border-radius: var(--radius-sm);
  }

  table {
    width: 100%;
    text-align: left;
    vertical-align: top;
  }

  thead > tr {
    background-color: var(--color-background-gray);
  }

  tr + tr {
    border-top: 1px solid var(--color-border);
  }

  th {
    font-size: var(--text-body-sm-size);
    line-height: var(--text-body-sm-narrow-line);
    color: var(--color-ubie-black-500);
  }

  td {
    font-size: var(--text-body-sm-size);
    line-height: var(--text-body-sm-narrow-line);
    word-break: break-word;
  }

  tr > th,
  tr > td {
    padding: var(--size-spacing-sm);
    vertical-align: top;
    border: none;
  }

  th.type,
  td.type {
    white-space: nowrap;
  }

  td.type code:first-child {
    margin-left: 0;
  }

  tbody > tr > th {
    color: var(--color-text-main);
  }

  th.nowrap {
    white-space: nowrap;
  }

  tbody > tr > td:first-child {
    font-weight: bold;
    color: var(--color-alert);
  }

  .required {
    font-size: var(--text-note-md-size);
    line-height: var(--text-note-md-line);
    color: var(--color-alert);
  }

  .optional {
    font-size: var(--text-note-md-size);
    font-weight: normal;
    line-height: var(--text-note-md-line);
    color: var(--color-text-sub);
  }
</style>
